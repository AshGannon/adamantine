/* Copyright (c) 2020 - 2024, the adamantine authors.
 *
 * This file is subject to the Modified BSD License and may not be distributed
 * without copyright and license information. Please refer to the file LICENSE
 * for the text and further information on this license.
 */

#include <DonutHeatSource.hh>
#include <instantiation.hh>
#include <types.hh>
#include <cmath> // For log and exp in Johnson-Cook model

namespace adamantine
{

// Constructor: Initializes the donut-shaped heat source for AFSD (Ti64)
// Retrieves the necessary parameters such as inner radius, rotation speed, strain rate, strain, and heat modifiers.
template <int dim>
DonutHeatSource<dim>::DonutHeatSource(boost::property_tree::ptree const &database)
    : HeatSource<dim>(database),
      _current_angle(0.0)
{
  // Retrieve the inner radius for the donut shape from the input file
  double inner_radius = database.get<double>("inner_radius");
  _inner_radius_squared = std::pow(inner_radius, 2);

  // Retrieve rotational parameters for AFSD, like spindle speed and heat modifiers
  _rotation_speed = database.get<double>("rotation_speed", 0.0); // Default to 0 if not provided
  _advancing_heat_modifier = database.get<double>("advancing_heat_modifier", 1.0);
  _retreating_heat_modifier = database.get<double>("retreating_heat_modifier", 1.0);

  // Retrieve parameters for the Johnson-Cook model:
  //Loading defaults for Ti-6Al-4V (Ti64) from Daridon, Oussouaddi, Ahzi 2004
  _yield_stress = database.get<double>("_yield_stress", 897.0);          // MPa
  _hardening_constant = database.get<double>("_hardening_constant", 850.0); // MPa
  hardening_exponent = database.get<double>("hardening_exponent", 0.28);
  strain_rate_sensitivity = database.get<double>("strain_rate_sensitivity", 0.014);
  thermal_softening_exponent = database.get<double>("thermal_softening_exponent", 1.1);
  reference_strain_rate = database.get<double>("reference_strain_rate", 1.0); // s^-1
  melting_temperature = database.get<double>("melting_temperature", 1878.0); // K
  reference_temperature = database.get<double>("reference_temperature", 298.0); // K
  friction_coefficient = database.get<double>("friction_coefficient", 0.5); // Default to 0.5 for Ti64

  // Retrieve strain and strain rate from the database
  strain = database.get<double>("strain", 0.1); // Default value 0.1
  strain_rate = database.get<double>("strain_rate", 5.0); // Default value 5.0 s^-1
}

// Function to compute the Johnson-Cook flow stress for Ti-6Al-4V
template <int dim>
double DonutHeatSource<dim>::compute_flow_stress(double temperature) const
{
  // Johnson-Cook model for flow stress (in MPa)
  double temp_factor = (1.0 - std::pow((temperature - reference_temperature) / (melting_temperature - reference_temperature), thermal_softening_exponent));
  double strain_rate_factor = (1.0 + strain_rate_sensitivity * std::log(strain_rate / reference_strain_rate));
  double flow_stress = (_yield_stress + _hardening_constant * std::pow(strain, hardening_exponent)) * strain_rate_factor * temp_factor;
  return flow_stress;
}

// Update the current time step and calculate heat input based on AFSD-specific factors (Ti64)
template <int dim>
void DonutHeatSource<dim>::update_time(double time)
{
  // Update the position of the beam (tool center) based on the scan path at the current time
  _beam_center = this->_scan_path.value(time);

  // Calculate the current angle based on rotation speed and time for rotating tool behavior
  _current_angle = std::fmod(_rotation_speed * time, 2.0 * dealii::numbers::PI);

  // Assume an example temperature for calculation (this could be dynamic)
  double temperature = 900.0; // Example temperature in Kelvin

  // Compute flow stress using Johnson-Cook model for Ti64 with the strain and strain rate loaded from the database
  double flow_stress = compute_flow_stress(temperature);

  // Compute frictional power and adiabatic heating for AFSD (Ti64)
  double friction_radius = 0.01; // Example tool radius in meters
  double contact_area = M_PI * friction_radius * friction_radius; // Contact area of the tool
  double layer_thickness = 0.005;  // Example thickness of the material in meters

         // Friction power: heat generated by the friction at the tool-material interface
  double friction_power = friction_coefficient * flow_stress * contact_area * friction_radius * _rotation_speed;

         // Adiabatic heating: heat generated due to plastic deformation, scaled by the Taylor-Quinney coefficient (e.g., 0.9)
  double adiabatic_power = 0.9 * flow_stress * strain_rate * contact_area * layer_thickness;

         // Simplified heat input term based on friction and adiabatic heating
  _alpha = (friction_power + adiabatic_power) / (contact_area * layer_thickness);
  //std::cout << "Heat input: " << _alpha << std::endl;
}

// This method calculates the heat source value at a given point in space and time.
// The result depends on the point's location relative to the tool, and whether it's on the advancing or retreating side.
template <int dim>
double DonutHeatSource<dim>::value(dealii::Point<dim> const &point, double const height) const
{
  // z-axis adjustment based on the height of the material
  double const z = point[axis<dim>::z] - height;

  // If the point is below the tool depth, no heat contribution
  if ((z + this->_beam.depth) < 0.)
  {
    return 0.;
  }
  else
  {
    // Calculate the radial distance from the beam center in the x-y plane
    double xpy_squared = std::pow(point[axis<dim>::x] - _beam_center[axis<dim>::x], 2);
    if (dim == 3)
    {
      xpy_squared += std::pow(point[axis<dim>::y] - _beam_center[axis<dim>::y], 2);
    }

    // Exclude points within the inner radius of the donut-shaped heat source (center of tool)
    if (xpy_squared < _inner_radius_squared)
    {
      return 0.;
    }

    // Calculate the angle of the point relative to the current rotation angle of the tool
    double point_angle = std::atan2(point[axis<dim>::y], point[axis<dim>::x]);
    double relative_angle = std::fmod(point_angle - _current_angle, 2.0 * dealii::numbers::PI);

    // Determine if the point is on the advancing side or retreating side
    // The advancing side is typically within +/- PI/2 of the tool's rotation direction
    double heat_modifier = (relative_angle >= -dealii::numbers::PI / 2.0 && relative_angle <= dealii::numbers::PI / 2.0)
                               ? _advancing_heat_modifier
                               : _retreating_heat_modifier;


    // Return the heat source value based on the friction and adiabatic heating, modified by the position in the x-y plane
    double heat_source = _alpha * heat_modifier * (xpy_squared - _inner_radius_squared);
    std::cout << "Heat source: " << heat_source << std::endl;
    return heat_source;
  }
}

} // namespace adamantine

INSTANTIATE_DIM(DonutHeatSource)
